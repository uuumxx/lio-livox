# lio code

Date: August 23, 2021

- #include<opencv2> `cv::FileStorage`
    - example

        ```python
        //1.è¯»å–æ–‡ä»¶æŒ‡é’ˆ	
        	string strSettingsFile = "./setting.yaml";
        	cv::FileStorage fread(strSettingsFile.c_str(),cv::FileStorage::READ);
        //1.åˆ›å»ºæ–‡ä»¶
        	cv::FileStorage fwrite("./setting.yaml",cv::FileStorage::WRITE);
        ```

- C++å¼ºåˆ¶ç±»å‹è½¬æ¢æ“ä½œç¬¦ static_cast
    - DETAIL

        /[https://www.cnblogs.com/QG-whz/p/4509710.html](https://www.cnblogs.com/QG-whz/p/4509710.html)

        static_castæ˜¯ä¸€ä¸ªå¼ºåˆ¶ç±»å‹è½¬æ¢æ“ä½œç¬¦ã€‚å¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œä¹Ÿç§°ä¸ºæ˜¾å¼è½¬æ¢ï¼ŒC++ä¸­å¼ºåˆ¶ç±»å‹è½¬æ¢æ“ä½œç¬¦æœ‰static_castã€dynamic_castã€const_castã€reinterpert_castå››ä¸ªã€‚æœ¬èŠ‚ä»‹ç»static_castæ“ä½œç¬¦ã€‚

- `pcl::PointXYZINormal`
    - DETAIL

        [PCLç‚¹äº‘æ•°æ®æ ¼å¼ï¼Œå¯ç”¨çš„PointTç±»å‹_u013925378çš„åšå®¢-CSDNåšå®¢](https://blog.csdn.net/u013925378/article/details/83537844)

        ```cpp
        PointXYZINormal

        æˆå‘˜å˜é‡:float x, y, z, intensity, normal[3], curvature;
        PointXYZINormalå­˜å‚¨XYZæ•°æ®å’Œå¼ºåº¦å€¼çš„pointç»“æ„ä½“ï¼Œå¹¶ä¸”åŒ…æ‹¬æ›²é¢æ³•çº¿å’Œæ›²ç‡ã€‚

        union
        {
            float data[4];
            struct
            {
                float x;
                float y;
                float z;
            };
        };
        union
        {
            float data_n[4];
            float normal[3];
            struct
            {
                float normal_x;
                float normal_y;
                float normal_z;
            };
        }
        union
        {
            struct
            {
                float intensity;
                float curvature;
            };
            float data_c[4];
        };
        ```

    - Normalç»“æ„ä½“è¡¨ç¤ºç»™å®šç‚¹æ‰€åœ¨æ ·æœ¬æ›²é¢ä¸Šçš„æ³•çº¿æ–¹å‘ï¼Œä»¥åŠå¯¹åº”æ›²ç‡çš„æµ‹é‡å€¼
        - ç”±äºåœ¨PCLä¸­å¯¹æ›²é¢æ³•çº¿çš„æ“ä½œå¾ˆæ™®éï¼Œè¿˜æ˜¯ç”¨ç¬¬å››ä¸ªå…ƒç´ æ¥å ä½ï¼Œè¿™æ ·å°±å…¼å®¹SSEå’Œé«˜æ•ˆè®¡ç®—
        - ä¾‹å¦‚ï¼šç”¨æˆ·è®¿é—®æ³•å‘é‡çš„ç¬¬ä¸€ä¸ªåæ ‡ï¼Œå¯ä»¥é€šè¿‡points[i].data_n[0]æˆ–è€…points[i].normal[0]æˆ–è€…points[i].normal_xï¼Œå†ä¸€æ¬¡å¼ºè°ƒï¼Œæ›²ç‡ä¸èƒ½è¢«å­˜å‚¨åœ¨åŒä¸€ä¸ªç»“æ„ä½“ä¸­ï¼Œå› ä¸ºå®ƒä¼šè¢«æ™®é€šçš„æ•°æ®æ“ä½œè¦†ç›–æ‰
- std::vector

    Vectoræ˜¯ä¸€ä¸ªå°è£…äº†åŠ¨æ€å¤§å°æ•°ç»„çš„é¡ºåºå®¹å™¨ï¼ˆSequence Containerï¼‰ã€‚è·Ÿä»»æ„å…¶å®ƒç±»å‹å®¹å™¨ä¸€æ ·ï¼Œå®ƒèƒ½å¤Ÿå­˜æ”¾å„ç§ç±»å‹çš„å¯¹è±¡ã€‚å¯ä»¥ç®€å•çš„è®¤ä¸ºï¼Œ**å‘é‡æ˜¯ä¸€ä¸ªèƒ½å¤Ÿå­˜æ”¾ä»»æ„ç±»å‹çš„åŠ¨æ€æ•°ç»„**ã€‚

- C++ï¼švectorä¸­ä½¿ç”¨.clear()å‡½æ•°

    vector.clear()çš„çœŸæ­£ä½œç”¨æ˜¯ï¼šæŠŠsizeè®¾ç½®æˆ0ï¼Œcapacityä¸å˜ã€‚

    å¦‚æœæƒ³è¦æ¸…é›¶vectorçš„è¯ï¼Œè¿˜æ˜¯å¾—é‡æ–°å®šä¹‰ä¸€ä¸ªvectorï¼Œæˆ–è€…ç”¨assignå‡½æ•°

- C++ï¼švectorä¸­çš„resize()å‡½æ•° VS reserve()å‡½æ•°
    - reserve
        - reserverå‡½æ•°ç”¨æ¥ç»™vectoré¢„åˆ†é…å­˜å‚¨åŒºå¤§å°ï¼Œå³capacityçš„å€¼ ï¼Œä½†æ˜¯**æ²¡æœ‰ç»™è¿™æ®µå†…å­˜è¿›è¡Œåˆå§‹åŒ–**
        - reserve çš„å‚æ•°næ˜¯æ¨èé¢„åˆ†é…å†…å­˜çš„å¤§å°ï¼Œå®é™…åˆ†é…çš„å¯èƒ½ç­‰äºæˆ–å¤§äºè¿™ä¸ªå€¼ï¼Œå³nå¤§äºcapacityçš„å€¼ï¼Œå°±ä¼šreallocateå†…å­˜ capacityçš„å€¼ä¼šå¤§äºæˆ–è€…ç­‰äºn
        - reserveåªä¿®æ”¹capacityå¤§å°ï¼Œä¸ä¿®æ”¹sizeå¤§å°ï¼Œresizeæ—¢ä¿®æ”¹capacityå¤§å°ï¼Œä¹Ÿä¿®æ”¹sizeå¤§å°
    - resize

        ```jsx
        void resize (size_type n);
        void resize (size_type n, value_type val);
        // resizeå‡½æ•°é‡æ–°åˆ†é…å¤§å°ï¼Œæ”¹å˜å®¹å™¨çš„å¤§å°ï¼Œå¹¶ä¸”åˆ›å»ºå¯¹è±¡
        ```

- c++ï¼š`void *calloc(size_t nitems, size_t size)`

    void *calloc(size_t nitems, size_t size) åˆ†é…æ‰€éœ€çš„å†…å­˜ç©ºé—´ï¼Œå¹¶è¿”å›ä¸€ä¸ªæŒ‡å‘å®ƒçš„æŒ‡é’ˆã€‚malloc å’Œ calloc ä¹‹é—´çš„ä¸åŒç‚¹æ˜¯ï¼Œmalloc ä¸ä¼šè®¾ç½®å†…å­˜ä¸ºé›¶ï¼Œè€Œ **calloc ä¼šè®¾ç½®åˆ†é…çš„å†…å­˜ä¸ºé›¶**ã€‚

- `pcl_isfinite()`

    ä½¿ç”¨pcl_isfiniteæˆ–pcl::removeNaNFromPointCloudå‡½æ•°å»é™¤æ— æ•ˆç‚¹

    ```jsx
    for (size_t i = 0; i < cloud->size (); ++i)
      {
        if (! pcl_isfinite ((*cloud)[i].x))
        {
          continue;
        }
    	}
    ```

- `msg->points.line`

    [æ¿€å…‰é›·è¾¾ä¸åŒæ‰«ææ–¹å¼å¾—åˆ°çš„æ•°æ®](https://blog.csdn.net/brightming/article/details/117533010)

    **livox horizon æ‰«ææ–¹å¼çš„å¤„ç†**

    ![Untitled](lio%20code%205a1f23e62e564b65b082467a96051024/Untitled.png)

    ```jsx
    æ¨ªå‘æ‰«ï¼Œ6æ¡çº¿ã€‚

    è¿™ç§æ¯ä¸ªç‚¹å¸¦æœ‰lineå·ï¼Œä¹Ÿç¡®å®æ˜¯ä¸€æ¡æ°´å¹³çš„çº¿ã€‚
    æ‰€ä»¥ï¼Œå¯ä»¥æ ¹æ®lineå·ç ï¼ŒæŒ‰ç…§ç‚¹çš„å…ˆåé¡ºåºï¼Œæ’åœ¨ä¸€èµ·å°±å¥½äº†ã€‚
    ç„¶åï¼Œå°†intensityï¼Œtimeoffsetç­‰ç»„åˆåœ¨pointxyziçš„å¯¹åº”å­—æ®µä¸­ã€‚
    ```

- pcl::PointXYZINormal PointType`laserCloud->push_back`

    [ç‚¹äº‘å¯¹è±¡çš„ä¸¤ç§å®šä¹‰æ–¹å¼çš„åŒºåˆ«ä¸è½¬æ¢](https://blog.csdn.net/qq_30815237/article/details/86509741)

    - ä¸€ç§vectorçš„èµ‹å€¼æ–¹å¼ï¼Œå°†pointæ•°æ®**push_back**åˆ°pcl::PointXYZINormalç±»å‹çš„æ¨¡æ¿ä¸­

        ```cpp
        pcl::PointCloud<pcl::PointXYZ> pointCloud;
        pcl::PointXYZ point;
              point.x = 2.0f - y;
              point.y = y;
              point.z = z;
              pointCloud.points.push_back(point);
        ```

    - æŒ‡é’ˆå‹ç±»æ¨¡æ¿ï¼Œé‡‡ç”¨â€œ->points[i]â€æ–¹å¼èµ‹å€¼

        ```cpp
        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);
        for (int i = 0; i < cloud->points.size (); ++i)
          {
            cloud->points[i].x = 1024 * rand () / (RAND_MAX + 1.0f);
            cloud->points[i].y = 1024 * rand () / (RAND_MAX + 1.0f);
            cloud->points[i].z = 1024 * rand () / (RAND_MAX + 1.0f);
          }
        ```

- c++ä¸­å‡½æ•°å‰åŠ ~`PCSeg::~PCSeg()`
    - ææ„å‡½æ•°(destructor)

        ææ„å‡½æ•°(destructor) ä¸æ„é€ å‡½æ•°ç›¸åï¼Œå½“å¯¹è±¡è„±ç¦»å…¶ä½œç”¨åŸŸæ—¶ï¼ˆä¾‹å¦‚å¯¹è±¡æ‰€åœ¨çš„å‡½æ•°å·²è°ƒç”¨å®Œæ¯•ï¼‰ï¼Œç³»ç»Ÿè‡ªåŠ¨æ‰§è¡Œææ„å‡½æ•°ã€‚ææ„å‡½æ•°å¾€å¾€ç”¨æ¥åšâ€œæ¸…ç†å–„åâ€ çš„å·¥ä½œï¼ˆä¾‹å¦‚åœ¨å»ºç«‹å¯¹è±¡æ—¶ç”¨newå¼€è¾Ÿäº†ä¸€ç‰‡å†…å­˜ç©ºé—´ï¼Œåº”åœ¨é€€å‡ºå‰åœ¨ææ„å‡½æ•°ä¸­ç”¨deleteé‡Šæ”¾ï¼‰ã€‚

        ```cpp
        PCSeg::PCSeg()
        {
            this->posFlag=0;
            this->pVImg=(unsigned char*)calloc(DN_SAMPLE_IMG_NX*DN_SAMPLE_IMG_NY*DN_SAMPLE_IMG_NZ,sizeof(unsigned char));
            this->corPoints=NULL;
        }
        PCSeg::~PCSeg()
        {
            if(this->pVImg!=NULL)
            {
                free(this->pVImg);
            }
            if(this->corPoints!=NULL)
            {
                free(this->corPoints);
            }
        }
        ```

- ç”¨æ³•`pcl::PointCloudpcl::PointXYZ::Ptr cloud(new pcl::PointCloudpcl::PointXYZ)`
    - Pcl::// PointCloudå’Œpcl::PointCloud::Ptrç±»å‹çš„è½¬æ¢ â€” åŠ äº†ptrçš„æ˜¯æŒ‡é’ˆç±»å‹ï¼Œä¸¤è€…å¯ä»¥äº’ç›¸è½¬æ¢

        ```cpp
        // 1.PointCloud::Ptrâ€”>PointCloud
        pcl::PointCloud<pcl::PointXYZ> cloud;
        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);
        cloud=*cloud_ptr;
        ```

        ```cpp

        // 2.PointCloudâ€”>PointCloud::Ptr
        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);
        pcl::PointCloud<pcl::PointXYZ> cloud;
        cloud_ptr=cloud.makeShared();
        ```

- `pcl::KdTreeFLANN`

    KdTreeFLANN is a generic type of 3D spatial locator using kD-tree structures

    [æ¢ç©¶PCLä¸­çš„kd-tree](https://zhuanlan.zhihu.com/p/144991935)

- `Eigen::Matrix3f` `Eigen::Vector3f`
    - Eigenä¸­æä¾›äº†è®¸å¤štypedefs ï¼Œ
        - typedef Vector3f æ˜¯ä¸€ä¸ªï¼ˆåˆ—ï¼‰å‘é‡ï¼štypedef Matrix<float, 3, 1> Vector3f;
        - Matrix3f æ˜¯3*3çš„floatå‹çŸ©é˜µ

        [Eigen Matrix è¯¦è§£_sn_gisçš„ä¸“æ -CSDNåšå®¢_matrixxd](https://blog.csdn.net/sn_gis/article/details/79015488)

- kdtree.radiusSearch
    - Search for all the nearest neighbors of the query point in a given radius (zero-copy).

    ```cpp
    virtual int pcl::KdTree< PointT >::radiusSearch 	( 	int  	index,
    		double  	radius,
    		Indices &  	**k_indices**,
    		std::vector< float > &  	**k_sqr_distances**,
    		unsigned int  	max_nn = 0 
    	) 		const

    [in]	point	the given query point
    [in]	radius	the radius of the sphere bounding all of p_q's neighbors
    [out]	**k_indices**	the resultant indices of the neighboring points
    [out]	**k_sqr_distances**	the resultant squared distances to the neighboring points
    ```

    - `return`: number of neighbors found in radius
- [pclä¸­pcaä¸»å…ƒåˆ†ææ³•çš„ç®€å•åº”ç”¨ï¼šè®¡ç®—ç‚¹äº‘ä¸»æ–¹å‘](https://www.freesion.com/article/7020306352/)
- è®¡ç®—è´¨å¿ƒ `pcl::compute3DCentroid`
- std::thread
    - C++æä¾›å¤´æ–‡ä»¶threadï¼Œä½¿ç”¨stdçš„threadå®ä¾‹åŒ–ä¸€ä¸ªçº¿ç¨‹å¯¹è±¡åˆ›å»º
    - std::thread åœ¨ #include å¤´æ–‡ä»¶ä¸­å£°æ˜ï¼Œå› æ­¤ä½¿ç”¨ std::thread æ—¶éœ€è¦åŒ…å« #include å¤´æ–‡ä»¶

    [std::threadï¼ˆçº¿ç¨‹ï¼‰_å‚»æœˆè‡å‡‰çš„åšå®¢-CSDNåšå®¢](https://blog.csdn.net/weixin_40087851/article/details/82685510)

- std::ref
    - std::refåªæ˜¯å°è¯•æ¨¡æ‹Ÿå¼•ç”¨ä¼ é€’ï¼Œå¹¶ä¸èƒ½çœŸæ­£å˜æˆå¼•ç”¨ï¼Œåœ¨éæ¨¡æ¿æƒ…å†µä¸‹ï¼Œstd::refæ ¹æœ¬æ²¡æ³•å®ç°å¼•ç”¨ä¼ é€’ï¼Œåªæœ‰æ¨¡æ¿è‡ªåŠ¨æ¨å¯¼ç±»å‹æ—¶ï¼Œrefèƒ½ç”¨åŒ…è£…ç±»å‹reference_wrapperæ¥ä»£æ›¿åŸæœ¬ä¼šè¢«è¯†åˆ«çš„å€¼ç±»å‹ï¼Œè€Œreference_wrapperèƒ½éšå¼è½¬æ¢ä¸ºè¢«å¼•ç”¨çš„å€¼çš„å¼•ç”¨ç±»å‹ï¼Œä½†æ˜¯å¹¶ä¸èƒ½è¢«ç”¨ä½œ`&`ç±»å‹ã€‚
    - è€Œå›åˆ°åˆšå¼€å§‹çš„é‚£ä¸ªå¤šçº¿ç¨‹ä»£ç ï¼Œthreadçš„æ–¹æ³•ä¼ é€’å¼•ç”¨çš„æ—¶å€™ï¼Œæˆ‘ä»¬å¸Œæœ›ä½¿ç”¨çš„æ˜¯å‚æ•°çš„å¼•ç”¨ï¼Œè€Œä¸æ˜¯æµ…æ‹·è´ï¼Œæ‰€ä»¥å¿…é¡»ç”¨refæ¥è¿›è¡Œå¼•ç”¨ä¼ é€’ã€‚
- `fabs`å‡½æ•°æ˜¯ä¸€ä¸ªæ±‚ç»å¯¹å€¼çš„å‡½æ•°
- pubFullLaserCloud.publish

- subscribeå’ŒadvertiseåŒºåˆ†
- `ros::spin()`
- `Eigen::Quaterniond` æ—‹è½¬å‘é‡è½¬å››å…ƒæ•°
- `pcl::fromROSMsg` å’Œ `pcl::toROSMsg`
    - [https://www.cnblogs.com/li-yao7758258/p/6651326.html](https://www.cnblogs.com/li-yao7758258/p/6651326.html)

        sensor_msgs::PointCloud2 <=> pcl::PointCloud<T>

- boost::shared_ptr æ˜¯å¯ä»¥å…±äº«æ‰€æœ‰æƒçš„æŒ‡é’ˆ

    å¦‚æœæœ‰å¤šä¸ªshared_ptrå…±åŒç®¡ç†åŒä¸€ä¸ªå¯¹è±¡æ—¶ï¼Œåªæœ‰è¿™äº›shared_ptrå…¨éƒ¨ä¸è¯¥å¯¹è±¡è„±ç¦»å…³ç³»ä¹‹åï¼Œè¢«ç®¡ç†çš„å¯¹è±¡æ‰ä¼šè¢«é‡Šæ”¾ã€‚

- [ç‚¹äº‘æ•°æ®æ ¼å¼è§£æ sensor_msgs::PointCloud2](https://blog.csdn.net/Fourier_Legend/article/details/83656798)
- ğŸ˜€[è§£æsensor_msgs::PointCloud2 ROSç‚¹äº‘æ•°æ®](https://blog.csdn.net/qq_32115419/article/details/105530070)
- [é€šè¿‡rvizè¯»å…¥.bagæ ¼å¼çš„æ–‡ä»¶å¹¶æ’­æ”¾](https://blog.csdn.net/qq_42451251/article/details/104839067)
- [sensor_msgs.PointCloud2](https://blog.csdn.net/SJTUzhou/article/details/85308805)
