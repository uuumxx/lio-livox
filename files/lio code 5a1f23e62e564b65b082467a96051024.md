# lio code

Date: August 23, 2021

- #include<opencv2> `cv::FileStorage`
    - example

        ```python
        //1.读取文件指针	
        	string strSettingsFile = "./setting.yaml";
        	cv::FileStorage fread(strSettingsFile.c_str(),cv::FileStorage::READ);
        //1.创建文件
        	cv::FileStorage fwrite("./setting.yaml",cv::FileStorage::WRITE);
        ```

- C++强制类型转换操作符 static_cast
    - DETAIL

        /[https://www.cnblogs.com/QG-whz/p/4509710.html](https://www.cnblogs.com/QG-whz/p/4509710.html)

        static_cast是一个强制类型转换操作符。强制类型转换，也称为显式转换，C++中强制类型转换操作符有static_cast、dynamic_cast、const_cast、reinterpert_cast四个。本节介绍static_cast操作符。

- `pcl::PointXYZINormal`
    - DETAIL

        [PCL点云数据格式，可用的PointT类型_u013925378的博客-CSDN博客](https://blog.csdn.net/u013925378/article/details/83537844)

        ```cpp
        PointXYZINormal

        成员变量:float x, y, z, intensity, normal[3], curvature;
        PointXYZINormal存储XYZ数据和强度值的point结构体，并且包括曲面法线和曲率。

        union
        {
            float data[4];
            struct
            {
                float x;
                float y;
                float z;
            };
        };
        union
        {
            float data_n[4];
            float normal[3];
            struct
            {
                float normal_x;
                float normal_y;
                float normal_z;
            };
        }
        union
        {
            struct
            {
                float intensity;
                float curvature;
            };
            float data_c[4];
        };
        ```

    - Normal结构体表示给定点所在样本曲面上的法线方向，以及对应曲率的测量值
        - 由于在PCL中对曲面法线的操作很普遍，还是用第四个元素来占位，这样就兼容SSE和高效计算
        - 例如：用户访问法向量的第一个坐标，可以通过points[i].data_n[0]或者points[i].normal[0]或者points[i].normal_x，再一次强调，曲率不能被存储在同一个结构体中，因为它会被普通的数据操作覆盖掉
- std::vector

    Vector是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，**向量是一个能够存放任意类型的动态数组**。

- C++：vector中使用.clear()函数

    vector.clear()的真正作用是：把size设置成0，capacity不变。

    如果想要清零vector的话，还是得重新定义一个vector，或者用assign函数

- C++：vector中的resize()函数 VS reserve()函数
    - reserve
        - reserver函数用来给vector预分配存储区大小，即capacity的值 ，但是**没有给这段内存进行初始化**
        - reserve 的参数n是推荐预分配内存的大小，实际分配的可能等于或大于这个值，即n大于capacity的值，就会reallocate内存 capacity的值会大于或者等于n
        - reserve只修改capacity大小，不修改size大小，resize既修改capacity大小，也修改size大小
    - resize

        ```jsx
        void resize (size_type n);
        void resize (size_type n, value_type val);
        // resize函数重新分配大小，改变容器的大小，并且创建对象
        ```

- c++：`void *calloc(size_t nitems, size_t size)`

    void *calloc(size_t nitems, size_t size) 分配所需的内存空间，并返回一个指向它的指针。malloc 和 calloc 之间的不同点是，malloc 不会设置内存为零，而 **calloc 会设置分配的内存为零**。

- `pcl_isfinite()`

    使用pcl_isfinite或pcl::removeNaNFromPointCloud函数去除无效点

    ```jsx
    for (size_t i = 0; i < cloud->size (); ++i)
      {
        if (! pcl_isfinite ((*cloud)[i].x))
        {
          continue;
        }
    	}
    ```

- `msg->points.line`

    [激光雷达不同扫描方式得到的数据](https://blog.csdn.net/brightming/article/details/117533010)

    **livox horizon 扫描方式的处理**

    ![Untitled](lio%20code%205a1f23e62e564b65b082467a96051024/Untitled.png)

    ```jsx
    横向扫，6条线。

    这种每个点带有line号，也确实是一条水平的线。
    所以，可以根据line号码，按照点的先后顺序，排在一起就好了。
    然后，将intensity，timeoffset等组合在pointxyzi的对应字段中。
    ```

- pcl::PointXYZINormal PointType`laserCloud->push_back`

    [点云对象的两种定义方式的区别与转换](https://blog.csdn.net/qq_30815237/article/details/86509741)

    - 一种vector的赋值方式，将point数据**push_back**到pcl::PointXYZINormal类型的模板中

        ```cpp
        pcl::PointCloud<pcl::PointXYZ> pointCloud;
        pcl::PointXYZ point;
              point.x = 2.0f - y;
              point.y = y;
              point.z = z;
              pointCloud.points.push_back(point);
        ```

    - 指针型类模板，采用“->points[i]”方式赋值

        ```cpp
        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);
        for (int i = 0; i < cloud->points.size (); ++i)
          {
            cloud->points[i].x = 1024 * rand () / (RAND_MAX + 1.0f);
            cloud->points[i].y = 1024 * rand () / (RAND_MAX + 1.0f);
            cloud->points[i].z = 1024 * rand () / (RAND_MAX + 1.0f);
          }
        ```

- c++中函数前加~`PCSeg::~PCSeg()`
    - 析构函数(destructor)

        析构函数(destructor) 与构造函数相反，当对象脱离其作用域时（例如对象所在的函数已调用完毕），系统自动执行析构函数。析构函数往往用来做“清理善后” 的工作（例如在建立对象时用new开辟了一片内存空间，应在退出前在析构函数中用delete释放）。

        ```cpp
        PCSeg::PCSeg()
        {
            this->posFlag=0;
            this->pVImg=(unsigned char*)calloc(DN_SAMPLE_IMG_NX*DN_SAMPLE_IMG_NY*DN_SAMPLE_IMG_NZ,sizeof(unsigned char));
            this->corPoints=NULL;
        }
        PCSeg::~PCSeg()
        {
            if(this->pVImg!=NULL)
            {
                free(this->pVImg);
            }
            if(this->corPoints!=NULL)
            {
                free(this->corPoints);
            }
        }
        ```

- 用法`pcl::PointCloudpcl::PointXYZ::Ptr cloud(new pcl::PointCloudpcl::PointXYZ)`
    - Pcl::// PointCloud和pcl::PointCloud::Ptr类型的转换 — 加了ptr的是指针类型，两者可以互相转换

        ```cpp
        // 1.PointCloud::Ptr—>PointCloud
        pcl::PointCloud<pcl::PointXYZ> cloud;
        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);
        cloud=*cloud_ptr;
        ```

        ```cpp

        // 2.PointCloud—>PointCloud::Ptr
        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr(new pcl::PointCloud<pcl::PointXYZ>);
        pcl::PointCloud<pcl::PointXYZ> cloud;
        cloud_ptr=cloud.makeShared();
        ```

- `pcl::KdTreeFLANN`

    KdTreeFLANN is a generic type of 3D spatial locator using kD-tree structures

    [探究PCL中的kd-tree](https://zhuanlan.zhihu.com/p/144991935)

- `Eigen::Matrix3f` `Eigen::Vector3f`
    - Eigen中提供了许多typedefs ，
        - typedef Vector3f 是一个（列）向量：typedef Matrix<float, 3, 1> Vector3f;
        - Matrix3f 是3*3的float型矩阵

        [Eigen Matrix 详解_sn_gis的专栏-CSDN博客_matrixxd](https://blog.csdn.net/sn_gis/article/details/79015488)

- kdtree.radiusSearch
    - Search for all the nearest neighbors of the query point in a given radius (zero-copy).

    ```cpp
    virtual int pcl::KdTree< PointT >::radiusSearch 	( 	int  	index,
    		double  	radius,
    		Indices &  	**k_indices**,
    		std::vector< float > &  	**k_sqr_distances**,
    		unsigned int  	max_nn = 0 
    	) 		const

    [in]	point	the given query point
    [in]	radius	the radius of the sphere bounding all of p_q's neighbors
    [out]	**k_indices**	the resultant indices of the neighboring points
    [out]	**k_sqr_distances**	the resultant squared distances to the neighboring points
    ```

    - `return`: number of neighbors found in radius
- [pcl中pca主元分析法的简单应用：计算点云主方向](https://www.freesion.com/article/7020306352/)
- 计算质心 `pcl::compute3DCentroid`
- std::thread
    - C++提供头文件thread，使用std的thread实例化一个线程对象创建
    - std::thread 在 #include 头文件中声明，因此使用 std::thread 时需要包含 #include 头文件

    [std::thread（线程）_傻月菇凉的博客-CSDN博客](https://blog.csdn.net/weixin_40087851/article/details/82685510)

- std::ref
    - std::ref只是尝试模拟引用传递，并不能真正变成引用，在非模板情况下，std::ref根本没法实现引用传递，只有模板自动推导类型时，ref能用包装类型reference_wrapper来代替原本会被识别的值类型，而reference_wrapper能隐式转换为被引用的值的引用类型，但是并不能被用作`&`类型。
    - 而回到刚开始的那个多线程代码，thread的方法传递引用的时候，我们希望使用的是参数的引用，而不是浅拷贝，所以必须用ref来进行引用传递。
- `fabs`函数是一个求绝对值的函数
- pubFullLaserCloud.publish

- subscribe和advertise区分
- `ros::spin()`
- `Eigen::Quaterniond` 旋转向量转四元数
- `pcl::fromROSMsg` 和 `pcl::toROSMsg`
    - [https://www.cnblogs.com/li-yao7758258/p/6651326.html](https://www.cnblogs.com/li-yao7758258/p/6651326.html)

        sensor_msgs::PointCloud2 <=> pcl::PointCloud<T>

- boost::shared_ptr 是可以共享所有权的指针

    如果有多个shared_ptr共同管理同一个对象时，只有这些shared_ptr全部与该对象脱离关系之后，被管理的对象才会被释放。

- [点云数据格式解析 sensor_msgs::PointCloud2](https://blog.csdn.net/Fourier_Legend/article/details/83656798)
- 😀[解析sensor_msgs::PointCloud2 ROS点云数据](https://blog.csdn.net/qq_32115419/article/details/105530070)
- [通过rviz读入.bag格式的文件并播放](https://blog.csdn.net/qq_42451251/article/details/104839067)
- [sensor_msgs.PointCloud2](https://blog.csdn.net/SJTUzhou/article/details/85308805)
